import * as esbuild from "esbuild"
import * as fs from "node:fs/promises";
import { copy } from "esbuild-plugin-copy";

import { build } from "tsup";

function parseCommand() { return process.argv[2]; }

class Playground
{
	createConfig = (mode: string): esbuild.BuildOptions => ({
		entryPoints: ["./playground/PlaygroundEntry.ts"],
		outdir: "./playground/dist",
		bundle: true,
		target: "ES2022",
		format: "esm",
		minify: mode === "build",
		conditions: ["worker", "browser"],
		treeShaking: true,
		metafile: true,
		splitting: true,
		sourcemap: "linked",
		entryNames: mode === 'build' ? "[name]-[hash]" : undefined,
		define: {
			"import.meta.DEV": mode === "dev" ? "true" : "false",
		},
		logLevel: "error",
		plugins: [
			copy({
				resolveFrom: 'cwd',
				assets: {
					from: ['./playground/assets/*'],
					to: ['./playground/dist/assets'],
				},
				watch: true,
			}),
		],
	})

	async dev()
	{
		const t = performance.now()
		await fs.mkdir("playground/dist", { recursive: true })
		await fs.writeFile("playground/dist/index.html", this.constructPlaygroundHtml("PlaygroundEntry.js"))

		const ctx = await esbuild.context(this.createConfig("dev"))

		await ctx.watch()

		await ctx.serve({
			servedir: 'playground/dist',
			fallback: 'playground/dist/index.html',
		})

		console.log(`Dev server started in ${(performance.now() - t).toFixed(1)} ms`)
	}

	async build()
	{
		console.info("Building playground for production")
		const t = performance.now()
		try { await fs.rm("playground/dist", { recursive: true }) } catch {}
		const output = await esbuild.build(this.createConfig("build"))
		const path = Object.entries(output.metafile!.outputs).find(([p, lol]) => lol.entryPoint === 'playground/PlaygroundEntry.ts')
		await fs.writeFile("playground/dist/index.html", this.constructPlaygroundHtml(path![0].replace('playground/dist', '')))
		console.log(`Built in ${(performance.now() - t).toFixed(1)} ms`)
	}

	constructPlaygroundHtml = (entry: string) => `
		<!DOCTYPE html>
		<html>
		<head>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1">
			<title>Elysia Playground</title>
			<script type="module" src="${entry}"></script>
		</head>
		<body></body>
		</html>`
}

async function generateModuleFiles()
{
	const preamble = `/* This file is generated by gen:modfiles. Do not modify. */\n\n`;

	const modules = await fs.readdir("src", { withFileTypes: true });

	const root: string[] = []

	for await (const module of modules)
	{
		if(module.isFile()) continue;
		root.push(module.name);
		// recurse and get the path of each file relative to it.
		const files = await fs.readdir(`src/${module.name}`, { withFileTypes: true });
		const paths: string[] = [];
		for await (const file of files) if (file.isFile() && file.name.endsWith(".ts") && !file.name.endsWith(".d.ts")) paths.push(`./${file.name.replace(".ts", "")}`);
		await fs.writeFile(`src/${module.name}/mod.ts`, preamble + paths.map(p => `export * from "${p}";`).join("\n"));
	}

	await fs.writeFile("src/mod.ts", preamble + root.map(p => `export * from "./${p}/mod";`).join("\n"));
}

function main()
{
	switch(parseCommand())
	{
		case "gen:modfiles":
			generateModuleFiles();
			break;
		case "playground:dev":
			new Playground().dev();
			break;
		case "playground:build":
			new Playground().build();
			break;
		case "playground:deploy":
			console.log("Deploying playground to Cloudflare Pages");
			break;
		default:
			console.log(
				`Usage: cli <command>\n\n`,
				`gen:modfiles        Generate modfiles`,
				`playground:dev     Start playground development server\n`,
				`playground:build   Build playground for production\n`,
				`playground:deploy  Deploy playground to Cloudflare Pages\n`
			)
	}
}

main();
